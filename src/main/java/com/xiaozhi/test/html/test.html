<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<table>
    这是HashMap的整理
    <tr>
        <th>遍历方法</th>
        <th>遍历集合</th>
        <th>所在类</th>
        <th>所在方法</th>
        <th>方法原理</th>
    </tr>
    <tr>
        <td rowspan="3">forEach/lambda遍历</td>
        <td>entrySet</td>
        <td>EntrySet</td>
        <td>forEach</td>
        <td colspan="6">遍历map的table[]</td>
    </tr>
    <tr>
        <td>keySet</td>
        <td>KeySet</td>
        <td>forEach</td>
    </tr>
    <tr>
        <td>values</td>
        <td>Values</td>
        <td>forEach</td>
    </tr>
    <tr>
        <td colspan="3">iterator遍历</td>
        <td>entrySet.iterator</td>
        <td>HashIterator及对应子类EntryIterator</td>
        <td colspan="3">nextNode\hasNext等</td>
    </tr>
    <tr>
        <td>keySet.iterator</td>
        <td>HashIterator及对应子类KeyIterator</td>
    </tr>
    <tr>
        <td>values.iterator</td>
        <td>HashIterator及对应子类ValueIterator</td>
    </tr>
</table>


---------------------------------------
<table width="100%" style="text-align: left;float: left" align="left" >
    <tr>
        <th width="5%">接口</th>
        <th width="10%">类</th>
        <th width="20%">属性</th>
        <th width="25%">特性</th>
        <th width="15%">线程安全</th>
        <th width="15%">常见注意问题</th>
        <td width="10%">比较</td>
    </tr>
    <tr>
        <td rowspan="3">List</td>
        <td>ArrayList</td>
        <td>初始大小：10<br>扩容：1.5倍<br>存储：Object[]</td>
        <td>顺序存储<br>随机访问快速<br>不易插入和删除某元素，需要执行数组拷贝</td>
        <td>不安全，fail-fast机制，可用Collections.synchronizedList(list)实现，其原理为给各个方法加对象锁（iterator()和listIterator()方法除外）</td>
        <td>subList()方法得到的是原list的试图，对某一方的修改会导致另一方的改变</td>
        <td rowspan="3">Vector的同步由synchronized修饰方法实现，而Collections.synchronizedList(list)实现同步为synchronized锁对象成代码块来调用原list对应方法，安全上后者更好但不用方法间也存在竞争</td>
    </tr>
    <tr>
        <td>LinkedList</td>
        <td>双向链表</td>
        <td>链表存储<br>方便插入删除操作<br>不能随机访问<br>遍历慢<br>有实现Queue接口，可当顺序队列使用</td>
        <td>不安全，fail-fast机制，安全实现同ArrayList(同上)</td>
        <td>subList问题（同上）</td>
    </tr>
    <tr>
        <td>Vector</td>
        <td>初始大小：10<br>扩容：如果构造函数传入扩容增量则为（原长度+增量）否则为（原长度*2），<br>存储：Object[]</td>
        <td>同ArrayList<br>有子类Stack</td>
        <td>安全，实现为所有方法增加synchronized关键字，其不保证多线程调不同方法出现错误。思考同步方法和同步代码块</td>
        <td>subList问题（同上）</td>
    </tr>
</table>

---------------------------------------
<table width="100%" style="text-align: left;float: left" align="left" >
    <tr>
        <th width="5%">接口</th>
        <th width="10%">类</th>
        <th width="15%">特性</th>
        <th width="20%">实现原理</th>
        <th width="15%">线程安全</th>
    </tr>
    <tr>
        <td rowspan="3">Set</td>
        <td>HashSet</td>
        <td>无序，唯一</td>
        <td>使HashMap成为其属性，使用HashMap的key存储</td>
        <td rowspan="3">不安全，可用Collections.synchronizedCollection()方法生成一个线程安全的对应集合</td>
    </tr>
    <tr>
        <td>LinkHashSet</td>
        <td>有序，按插入顺序</td>
        <td>使LinkHashMap成为其属性，使用其的key存储，有序原理和LinkHashMap一样，Entry中留有指向前后节点的引用</td>
    </tr>
    <tr>
        <td>TreeSet</td>
        <td>有序，按元素的比较器排序</td>
        <td>使TreeMap成为其属性，使用其key存储，内部为红黑树</td>
    </tr>
</table>

</body>
</html>